//
//  DataStore.swift
//  SwiftSecrets
//
//  Created by Yuri Volegov on 12.04.2023.
//

import Foundation

final class DataStore {
    static var share = DataStore()
    private init() {}
}

extension DataStore {
    func getSecrets() -> [Secret] {
        [
            Secret(
                title: "Delegate",
                image: [""],
                matherials: [
    """
    Паттерн - шаблон который используется для реализации конкретных действий
    
    "Паттерн делегирования" в Swift - это шаблон проектирования, который позволяет объекту передавать свои обязанности или события другому объекту, называемому делегатом. Этот шаблон используется для уменьшения связности между объектами и улучшения повторного использования кода.
    
    Суть паттерна Делегирование:
    1. Объект(руководящий) определяет свойство с типом протокола, оканчивающимся на "Delegate" (например: SettingsViewControllerDelegate). В том же файле с объектом объявлен протокол, оканчивающийся на "Delegate", в котором описываются те свойства и методы, которые должен будет реализовать объект-делегат.
    2. Объект-делегат(исполнитель) должен быть подписан на протокол оканчивающийся на "Delegate". Так как он подписан на данный протокол, то обязательно должен реализовать требуемые свойства и методы.
    3. Экземпляр Объекта-делегата должен быть передан в свойство Объекта(руководящего) с типом протокола оканчивающегося на "Delegate"
    4. В результате мы передаёем не объект целеком, а только те свойства и методы которые он должен реализовывать. Для этих целей мы используем протокол как описано в пунктах 1-3.
    
    В Swift делегирование реализуется с помощью протоколов и свойства делегата. Объект, который хочет передать свои обязанности или события, определяет протокол, который описывает эти обязанности или события. Затем этот объект имеет свойство делегата, которое является ссылкой на объект, реализующий этот протокол.
    
    Когда объект хочет передать свои обязанности или события, он вызывает методы протокола через свойство делегата. Объект-делегат реализует эти методы и выполняет необходимые действия.
    
    Примером использования паттерна делегирования в Swift может быть UITableView, который передает свои обязанности по отображению и управлению ячейками делегату, реализующему протокол UITableViewDelegate и UITableViewDataSource.
    
    Как определить кто главный(руководящий), а кто исполнитель? Кто такой делегат?
    
    Объект-делегат по определению - это подчинённый объект или "объект исполнитель", который реализует требуемые методы.  Объект-делегат должен быть подписан на протокол оканчивающийся на "Delegate" для того, чтобы его можно было передать свойству Объекта с типом одноимённом с протоколом оканчивающимся на "Delegate". Например, FirstScreenViewController это подчинённый, если подписан на SecondViewControllerDelegate: "FirstScreenViewController: SecondViewControllerDelegate". Также объект, подписанный на протокол SecondViewControllerDelegate, передаётся в другой класс через свойство с типом SecondViewControllerDelegate.
    
    Главный(руководящий) же объект, как правило хранит протокол (в том же файле где объявлен сам), имя которого задаётся по следующему принципу: имя главного объекта + слово "Delegate"на конце. Таким образом можно сказать, что главный объект тот, чьим именем назван протокол, например, если протокол делегирования назван "SecondViewControllerDelegate", то это означает: главный это SecondViewController, в классе SecondViewController описан и хранится протокол SecondViewControllerDelegate, а подчинённым может быть любой экземпляр любого типа данных подписанный на протокол SecondViewControllerDelegate и реализующий все его требования.
    
    Пример:
    FirstScreenViewController: SecondViewControllerDelegate - подчинённый реализует только те требования, которые диктует ему (передаёт на исполнение) SecondViewController через протокол SecondViewControllerDelegate, который как правило описан в файле вместе с руководящим классом SecondViewController.
    """
                ],
                questions: [
                    Question(
                        title: "Определите объект-делегат, если FirstScreenViewController: SecondViewControllerDelegate",
                        answers: ["FirstScreenViewController", "SecondViewControllerDelegate", "Оба", "Объектов-делегатов не существует?"],
                        best: 0
                    ),
                    Question(
                        title: "Где как правило описывается(хранится) протокол, оканчивающийся на Delegate?",
                        answers: ["В отдельном файле с протоколами", "В файле объекта-делегата(так удобнее)", "В файле руководящего объекта", "В документации XCode"],
                        best: 2
                    ),
                    Question(
                        title: "Что мы передаём в качестве исполнителя?",
                        answers: ["Объект-делегат", "Объект исполнитель", "Себя", "Ничего, так как протокол оканчивающийся на Delegate работает во всём приложении вне завимости от мета где объявлен"],
                        best: 0
                    )
                ]
            ),
            Secret(
                title: "CoreData",
                image: ["CoreData"],
                matherials: [
    """
    Для создания хранилища в приложении используются классы NSPersistentStoreCoordinator или NSPersistentContainer. NSPersistentStoreCoordinator создает хранилище указанного типа на основе модели, можно указать размещение и дополнительные опции. NSPersistentContainer можно использовать с IOS10, дает возможность создания с минимальным количеством кода.
    
    Работает это следующим образом: если по указанному пути существует база данных, то координатор проверяет ее версию и, при необходимости, делает миграцию. Если база не существует, то она создается на основании модели NSManagedObjectModel. Чтобы все это работало правильно, перед внесением изменений в модель создавайте новую версию в Xcode через меню Editor -> Add Model Version. Если вывести путь, то можно найти и открыть базу в эмуляторе.
    
    Core Data использует 4 типа хранилища:
    
    — SQLite
    — Binary
    — In-Memory
    — XML (только для Mac OS)
    
    Если, например, по соображениям безопасности Вы не хотите хранить данные в файловом виде, но при этом хотите использовать кеширование в течении сессии и данные в виде объектов, вполне подойдет хранилище типа «In-Memory». Собственно, не запрещается иметь в одном приложении несколько хранилищ разного типа.
    
    Несколько слов хочется сказать об объекте NSManagedObjectContext. Вообще, Apple дает весьма туманную формулировку для NSManagedObjectContext — среда для работы с объектами Core Data. Все это от желания отмежеваться от ассоциаций с реляционными базами, и представить Core Data, как простое в использовании средство, не требующее понимания ключей, транзакций и прочей базданской атрибутики. Но на языке реляционных баз NSManagedObjectContext можно, в некотором смысле, назвать менеджером транзакций. Вы, наверное, заметили, что он имеет методы save и rollback, хотя скорее всего вы пользуетесь только первым.
    
    Недопонимание этого простого факта, приводит к использованию одноконтекстной модели, даже в тех ситуациях, где ее недостаточно. К примеру, вы редактируете большой документ, и при этом вам потребовалось загрузить пару справочников. В какой момент вызывать save? Если бы мы работали с реляционной базой, то тут бы не возникло вопросов, поскольку каждая операция выполнялась бы в своей транзакции. В Core Data тоже есть вполне удобный способ для решения этой проблемы — это ответвление дочернего контекста. Но к сожалению, это почему-то используется редко.
    """
                ],
                questions: [
                    Question(
                        title: "Какой класс нужно использовать для создания хранилища указанного типа на основе модели?",
                        answers: ["NSPersistentStoreCoordinator", "NSManagedObjectContext", "NSManagedObjectModel", "NSPersistentContainer"],
                        best: 0
                    ),
                    Question(
                        title: "Какой тип хранилища не использует CoreData?",
                        answers: ["SQLite", "Binary", "In-Memory", "SQL"],
                        best: 3
                    ),
                    Question(
                        title: "Хранилище какого типа подойдет для кеширования во время сессии данных ввиде объектов?",
                        answers: ["SQLite", "Binary", "In-Memory", "XML"],
                        best: 2
                    )
                ]
            )
            
        ]
        
    }
}
